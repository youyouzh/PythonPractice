第一部分：基础入门卷
第一篇：Python语言体系 26
第一章：标准输入与输出 26
1.1 标准输入功能 1.1.1
1.2 标准输出功能 1.1.2
1.3 格式化的用法 1.1.3
第二章：数据类型与结构 29
2.1 算数类型 2.1.1
2.2 字符类型 2.1.2
2.3 列表类型 2.1.3
2.4 字典类型 2.1.4
2.5 元组类型 2.1.5
2.6 集合类型 2.1.6
2.7 序列类型 2.1.7
第三章：迭代器与生成器 66
3.1 使用迭代器 3.1.1
3.2 使用生成器 3.1.2
3.3 队列的使用 3.1.3
第四章：变量与作用域 73
第五章：定义并使用函数 76
5.1 有参与无参函数 5.1.1
5.2 函数参数传递 5.1.2
5.3 通用函数返回值 5.1.3
5.4 通用函数闭包 5.1.4
5.5 函数嵌套与递归 5.1.5
5.6 LAMBDA匿名函数 5.1.6
第六章：函数装饰器 86
6.1 无参装饰器 6.1.1
6.2 有参装饰器 6.1.2
6.3 带参装饰器 6.1.3
第七章：面向对象编程 91
7.1 面向对象之封装 7.1.1
7.2 面向对象之继承 7.1.2
7.3 面向对象之包装 7.1.3
7.4 面向对象之反射 7.1.4
第八章：进程与线程 106
8.1 创建并使用线程 8.1.1
8.2 创建并使用进程 8.1.2
8.3 多进程数据共享 8.1.3
第九章：内置模块应用 119
9.1 系统操作模块 9.1.1
9.2 文本处理模块 9.1.2
9.3 加密解密模块 9.1.3
9.4 取随机数模块 9.1.4
9.5 日期时间模块 9.1.5
9.6 持久存储模块 9.1.6
9.7 INI解析模块 9.1.7
9.8 XML处理模块 9.1.8
9.9 Ctypes混编模块 9.1.9
第二篇：C/C++语言体系 156
第一章：使用数组与指针 156
第二章：使用函数与指针 174
第三章：使用字符与指针 182
第四章：使用结构与指针 194
第五章：使用文件与指针 205
第六章：封装实现字操作 222
6.1 封装字符串操作 6.1.1
6.2 复制与剪切函数 6.1.2
6.3 字符串比较函数 6.1.3
6.4 字符串查找函数 6.1.4
第七章：指针与数据结构 266
7.1 实现动态数组 7.1.1
7.2 实现动态链表 7.1.2
7.3 实现顺序栈 7.1.3
7.4 实现链表栈 7.1.4
7.5 实现链表队列 7.1.5
第八章：标准输入输出流 286
第九章：引用与取别名 293
第十章：定义并使用类 297
第十一章：运算符重载 309
第十二章：继承与多态 318
第十三章：泛型化编程 326
第三篇：C++ STL模板体系 333
第一章：字符串操作容器 334
1.1 字符串构造函数 1.1.1
1.2 字符串对象赋值 1.1.2
1.3 字符串遍历操作 1.1.3
1.4 字符串添加与删除 1.1.4
1.5 字符串查找与替换 1.1.5
1.6 字符串首尾数据提取 1.1.6
1.7 字符串与字符互转 1.1.7
1.8 字符串大小写互转 1.1.8
第二章：数组向量容器 340
2.1 数组向量基础应用 2.1.1
2.2 数组向量正/反向遍历 2.1.2
2.3 数组向量正/反向排序 2.1.3
2.4 向数组向量中插入元素 2.1.4
2.5 向数组向量中插入结构指针 2.1.5
2.6 向数组向量中插入类指针 2.1.6
2.7 在数组容器中嵌套容器 2.1.7
2.8 函数参数定义为容器类型 2.1.8
2.9 数组向量元素的删除 2.1.9
第三章：双向队列容器 348
3.1 单向队列的基本操作 3.1.1
3.2 双向队列的基本操作 3.1.2
3.3 双向队列正/反向遍历 3.1.3
3.4 双向队列插入/弹出元素 3.1.4
3.5 函数参数传递双向队列 3.1.5
第四章：动态链表容器 352
4.1 双向链表遍历整数 4.1.1
4.2 双向链表遍历结构体 4.1.2
4.3 实现正反向遍历链表 4.1.3
4.4 遍历链表中指定元素 4.1.4
4.5 插入/删除链表元素 4.1.5
4.6 整数链表正反向排序 4.1.6
4.7 类链表正反向排序 4.1.7
4.8 类链表成员的删除 4.1.8
第五章：集合数据容器 361
5.1 正反向遍历集合元素 5.1.1
5.2 查找集合中指定元素 5.1.2
5.3 设置默认集合排序方式 5.1.3
5.4 向集合插入自定义类型 5.1.4
第六章：序列映射容器 365
6.1 通过对组实现键值对 6.1.1
6.2 正反向遍历映射容器 6.1.2
6.3 查找映射容器中的元素 6.1.3
6.4 遍历映射容器中的结构 6.1.4
6.5 通过映射容器实现分组 6.1.5
第七章：非变易算法(查找算法) 370
7.1 for_each 遍历容器元素 7.1.1
7.2 find 普通查找容器元素 7.1.2
7.3 find 类查找容器元素 7.1.3
7.4 find_if 条件查找容器元素 7.1.4
7.5 find_if 条件查找类容器元素 7.1.5
7.6 adjacent_find 邻近查找容器元素 7.1.6
7.7 find_first_of 范围查找容器元素 7.1.7
7.8 count 普通元素计数统计 7.1.8
7.9 count_if 条件元素计数统计 7.1.9
7.10 binary_search 数组查找算法 7.1.10
7.11 mismatch 元素不匹配查找 7.1.11
7.12 equal 元素相等的判断 7.1.12
7.13 search 子序列搜索算法 7.1.13
7.14 search_n 重复元素子序列搜索 7.1.14
7.15 find_end 最后一个子序列搜索 7.1.15
第八章：变易算法(复制与拷贝) 383
8.1 copy 元素复制算法 8.1.1
8.2 swap 元素交换算法 8.1.2
8.3 transform 元素搬运算法 8.1.3
8.4 replace 元素替换算法 8.1.4
8.5 fill 容器元素初始化算法 8.1.5
8.6 remove_if 普通条件移除 8.1.6
8.7 remove_copy 条件移除复制 8.1.7
8.8 unique 容器元素去重算法 8.1.8
8.9 reverse 元素反向拷贝算法 8.1.9
8.10 rotate 容器旋转复制算法 8.1.10
8.11 random 随机数相关算法 8.1.11
8.12 partition 容器元素分割算法 8.1.12
第九章：排序/算数/集合 395
9.1 堆排序算法 9.1.1
9.2 局部排序与复制 9.1.2
9.3 快速排序算法 9.1.3
9.4 稳定排序算法 9.1.4
9.5 容器归并算法 9.1.5
9.6 容器区间查找算法 9.1.6
9.7 最大值/最小值算法 9.1.7
9.8 交集/并集/差集算法 9.1.8
9.9 求容器上/下排列组合 9.1.9
9.10 容器元素求和算法 9.1.10
第十章：模板适配/迭代器 407
10.1 函数对象适配器 10.1.1
10.2 函数指针适配器 10.1.2
10.3 容器取反适配器 10.1.3
10.4 文件流对象拷贝文件 10.1.4
10.5 向前/后插入迭代器 10.1.5
10.6 容器反向迭代器 10.1.6
第十一章：STL综合应用 413
11.1 字典拆分为列表 11.1.1
11.2 列表合并为字典 11.1.2
11.3 根据字典Key排序(降序) 11.1.3
11.4 根据字典key排序(长度) 11.1.4
11.5 根据字典Value排序 11.1.5
11.6 根据字典Key返回Value 11.1.6
11.7 根据字典Value寻找Key 11.1.7
11.8 寻找列表中相同元素 11.1.8
11.9 查找列表中的交集 11.1.9
11.10 根据Key设置字典Value 11.1.10
11.11 实现列表容器计数 11.1.11
11.12 验证两个列表异同点 11.1.12
11.13 实现两个列表合并 11.1.13
11.14 字典与列表的嵌套 11.1.14
11.15 可存储多类型容器 11.1.15
11.16 列表随机弹出元素 11.1.16
11.17 实现队列参数计算 11.1.17
11.18 查找最大值/最小值 11.1.18
11.19 字典中嵌套结构体 11.1.19
第四篇：Boost 准标准库体系 440
第一章：字符串处理库 442
1.1 字符串格式转换 1.1.1
1.2 字符串格式输出 1.1.2
1.3 字符串大小写转换 1.1.3
1.4 字符串判断与测试 1.1.4
1.5 字符串修正与裁剪 1.1.5
1.6 字符串匹配开头结尾 1.1.6
1.7 字符串替换与删除 1.1.7
1.8 字符串切割与合并 1.1.8
1.9 整数转字符串并合并 1.1.9
1.10 字符串查找/分割迭代器 1.1.10
1.11 正则分组匹配字符串 1.1.11
1.12 正则查找替换 1.1.12
1.13 正则迭代与分词 1.1.13
1.14 正则切割与过滤 1.1.14
第二章：内存池管理库 459
2.1 使用Pool内存池 2.1.1
2.2 使用ObjectPool内存池 2.1.2
2.3 使用SharedPtr智能指针 2.1.3
2.4 使用MakeShared工厂函数 2.1.4
2.5 使用SharedPtr桥接模式 2.1.5
2.6 使用SharedPtr工厂模式 2.1.6
2.7 使用SharedPtr资源共享 2.1.7
2.8 使用WeakPtr智能指针 2.1.8
2.9 使用IntrusivePtr计数器 2.1.9
第三章：日期时间操作库 474
3.1 字符串与日期时间互转 3.1.1
3.2 度量时间流失单位 3.1.2
3.3 Ptime与Time_T互转 3.1.3
3.4 日期的格式化输出 3.1.4
3.5 日期的加减运算 3.1.5
3.6 指定日期区间与变动区间 3.1.6
3.7 日期区间范围判断 3.1.7
3.8 使用日期迭代器 3.1.8
3.9 时钟与时间点 3.1.9
3.10 时间基本操作 3.1.10
3.11 时间点加减法 3.1.11
3.12 时间点格式化输出 3.1.12
3.13 时间区间操作 3.1.13
3.14 时间长度计算 3.1.14
第四章：数据集序列化库 489
4.1 针对文本的序列化 4.1.1
4.2 针对数组的序列化 4.1.2
4.3 针对结构体的序列化 4.1.3
4.4 嵌套结构体的序列化 4.1.4
4.5 针对类的序列化 4.1.5
4.6 序列化文本到字符串 4.1.6
4.7 序列化数组到字符串 4.1.7
4.8 序列化结构体到字符串 4.1.8
4.9 序列化嵌套结构到字符串 4.1.9
4.10 序列化类到字符串 4.1.10
4.11 序列化派生类到字符串 4.1.11
第五章：文件目录操作库 505
5.1 使用Path目录类 5.1.1
5.2 路径拼接与追加操作 5.1.2
5.3 针对文件属性操作 5.1.3
5.4 文件流计算文件大小 5.1.4
5.5 文件与目录增删改 5.1.5
5.6 迭代输出单层目录 5.1.6
5.7 正则迭代搜索文件 5.1.7
5.8 递归遍历层级目录 5.1.8
5.9 递归实现文件拷贝 5.1.9
5.10 递归实现文件删除 5.1.10
5.11 递归目录计算CRC32 5.1.11
5.12 非递归输出目录属性 5.1.12
第六章：函数绑定回调库 525
6.1 reference_wrapper包装器 6.1.1
6.2 Bind 函数绑定 6.1.2
6.3 Function 函数绑定 6.1.3
6.4 Signals 信号与槽 6.1.4
第七章：多线程并发库 541
7.1 Mutex互斥锁 7.1.1
7.2 线程局部存储 7.1.2
7.3 使用线程组 7.1.3
7.4 获取线程返回值 7.1.4
7.5 shared_mutex共享锁 7.1.5
7.6 获取线程ID号 7.1.6
第八章：应用JSON解析库 555
8.1 解析单个节点 8.1.1
8.2 解析单个列表 8.1.2
8.3 解析嵌套列表 8.1.3
8.4 解析多层字典 8.1.4
8.5 写出JSON文件 8.1.5
8.6 自定义的结构解析 8.1.6
第九章：命令行解析库 564
9.1 在字符串上解析 9.1.1
9.2 自己实现的参数解析 9.1.2
9.3 交互式参数解析器 9.1.3
9.4 非交互参数解析 9.1.4
第五篇：Intel 汇编语言体系 572
第一章：汇编语言基础 572
1.1 RadASM 1.1.1
1.2 汇编中的变量 1.1.2
1.3 标准输入与输出 1.1.3
第二章：标志位测试指令 577
2.1 PSR 2.1.1
2.2 TEST 2.1.2
2.3 CMP 2.1.3
2.4 JX/JNX/JSX/JPX 2.1.4
2.5 BT/BTR/BSF/BSR 2.1.5
第三章：字符串操作指令 586
3.1 MOVSB/MOVSW/MOVSD 3.1.1
3.2 CMPSB/CMPSW/CMPSD 3.1.2
3.3 SCASB/SCASW/SCASD 3.1.3
3.4 STOSB/STOSW/STOSD 3.1.4
3.5 LODSB/LODSW/LODSD 3.1.5
第四章：算数运算指令集 595
4.1 MOV/INC/DEC/XCHG 4.1.1
4.2 ADD/SUB 4.1.2
4.3 NEG/NOT 4.1.3
4.4 AND/OR/XOR 4.1.4
4.5 SHL/SHR 4.1.5
4.6 SAL/SAR 4.1.6
4.7 ROL/ROR 4.1.7
4.8 RCL/RCR 4.1.8
4.9 MUL/IMUL 4.1.9
4.10 DIV/IDIV 4.1.10
4.11 ADC/SBB 4.1.11
第五章：汇编函数调用约定 625
5.1 CDECL 5.1.1
5.2 STDCALL 5.1.2
5.3 FASTCALL 5.1.3
5.4 使用ESP寄存器寻址 5.1.4
5.5 使用数组指针传值 5.1.5
5.6 指向函数的指针 5.1.6
第六章：汇编高效数组寻址 636
6.1 数组取值操作 6.1.1
6.2 数组直接寻址 6.1.2
6.3 数组间接寻址 6.1.3
6.4 比例因子寻址 6.1.4
6.5 数组指针寻址 6.1.5
6.6 模拟二维数组寻址 6.1.6
6.7 模拟三维数组寻址 6.1.7
第七章：汇编高效乘法运算 649
7.1 使用IMUL指令完成乘法 7.1.1
7.2 使用LEA指令替换乘法 7.1.2
7.3 使用LEA指令拆分计算 7.1.3
7.4 使用LEA指令递减计算 7.1.4
7.5 使用SHL计算无符号乘法 7.1.5
7.6 使用SAL计算有符号乘法 7.1.6
第八章：汇编高效除法运算 654
8.1 使用IDIV指令完成除法 8.1.1
8.2 除数为正2的次幂(无符号) 8.1.2
8.3 除数为负2的次幂(有符号) 8.1.3
8.4 被除数为负数(有符号) 8.1.4
8.5 除数与被除数均为负数(有符号) 8.1.5
8.6 除数为正非2次幂(有符号) 8.1.6
8.7 除数为正非2次幂(无符号) 8.1.7
8.8 除数为负非2次幂(无符号) 8.1.8
第九章：浮点数操作指令 664
9.1 FLD/FSTP 9.1.1
9.2 FCHS/FABS 9.1.2
9.3 FADD/FADDP/FIADD 9.1.3
9.4 FSUB/FSUBP/FISUB 9.1.4
9.5 FMUL/FMULP/FIMUL 9.1.5
9.6 FDIV/FDIVP/FIDIV 9.1.6
9.7 FCOM/FCOMP/FCOMPP 9.1.7
第十章：汇编过程与结构 678
10.1 PUSH/POP 10.1.1
10.2 PROC/ENDP 10.1.2
10.3 局部参数传递 10.1.3
10.4 USES/ENTER 10.1.4
10.5 STRUCT/UNION 10.1.5
第十一章：仿写控制流程 697
11.1 IF中的AND语句构造 11.1.1
11.2 IF中OR语句的构造 11.1.2
11.3 IF中AND/OR混合构造 11.1.3
11.4 IF语句中的条件测试 11.1.4
11.5 IF语句的双重嵌套 11.1.5
11.6 IF语句的三层嵌套 11.1.6
11.7 IF语句的多选择分支 11.1.7
11.8 IF中的自增自减处理 11.1.8
11.9 IF中的三目运算符 11.1.9
11.10 IF中的嵌套移位 11.1.10
11.11 IF中的运算符混合 11.1.11
11.12 Do-While 循环结构优化 11.1.12
11.13 While 循环结构优化 11.1.13
11.14 FOR 循环结构优化 11.1.14
11.15 Loop 循环结构优化 11.1.15
11.16 仿写Do-While循环体 11.1.16
11.17 仿写While循环体 11.1.17
11.18 仿写While三层嵌套循环体 11.1.18
11.19 仿写While实现二分法 11.1.19
11.20 仿写For水仙花数 11.1.20
11.21 For循环尝试判断 11.1.21
11.22 For循环多重IF判断 11.1.22
11.23 For嵌套乘法口诀表 11.1.23
11.24 For语句冒泡排序 11.1.24
11.25 Switch 仿写有序线性优化 11.1.25
11.26 Switch 仿写非线性索引优化 11.1.26
11.27 Switch 仿写平衡判定树优化 11.1.27
第二部分：安全编程卷
第一篇：ShellCode编写与应用技术 756
1.1 Metasploit 工具简介 756
1.2 Metasploit 生成并使用后门 757
1.2.1 通用控制命令 1.2.1
1.2.2 Migrate进程迁移 1.2.2
1.2.3 文件查阅与传输 1.2.3
1.2.4 端口转发与扫描 1.2.4
1.2.5 信息采集功能 1.2.5
1.2.6 目标主机权限提升 1.2.6
1.2.7 添加用户与开启远程 1.2.7
1.2.8 注册表写入后门 1.2.8
1.3 Metasploit 生成SSL加密载荷 767
1.3.1 通过MSF模块克隆证书 1.3.1
1.3.2 通过OpenSSL制作证书 1.3.2
1.4 编写简易ShellCode弹窗 777
1.4.1 寻找DLL库函数地址 1.4.1
1.4.2 探讨STDCALL调用约定 1.4.2
1.4.3 ShellCode提取与应用 1.4.3
1.5 编写自定位ShellCode弹窗 780
1.5.1 动态查找Kernel32基址 1.5.1
1.5.2 动态查找并枚举进程模块 1.5.2
1.5.3 计算函数Hash摘要值 1.5.3
1.5.4 枚举Kernel32导出表 1.5.4
1.5.5 整合自定位ShellCode 1.5.5
1.6 编写双管道ShellCode后门 803
1.6.1 什么是匿名管道 1.6.1
1.6.2 C语言实现双管道后门 1.6.2
1.6.3 汇编实现并提取ShellCode 1.6.3
1.7 完善自定位ShellCode后门 820
1.7.1 通过PEB定位GetProcAddress 1.7.1
1.7.2 汇编实现动态定位功能 1.7.2
1.7.3 运用SEH链获得Kernel32基址 1.7.3
1.8 运用C编写ShellCode代码 831
1.9 动态解密ShellCode反弹 841
1.10 内存ShellCode格式化与注入 847
1.10.1 针对内存的ShellCode注入 1.10.1
1.10.2 实现格式化与代码执行盒 1.10.2
1.11 动态加载ShellCode绕过杀软 853
1.11.1 探索Socket服务端 1.11.1
1.11.2 探索Socket客户端 1.11.2
1.12 进程注入ShellCode套接字 862
1.12.1 读入Kernel32模块基址 1.12.1
1.12.2 进程注入MsgBox弹窗 1.12.2
1.12.3 进程注入MyShell正向后门 1.12.3
1.13 导出表劫持ShellCode加载 874
1.13.1 动态链接库加载顺序 1.13.1
1.13.2 实现DLL劫持代码生成 1.13.2
1.13.3 实现劫持ShellCode注入 1.13.3
1.14 手工插入ShellCode反弹后门 886
1.14.1 VA地址与FOA地址互转 1.14.1
1.14.2 新建节区并插入后门 1.14.2
1.14.3 新建节并插入DLL 1.14.3
1.15 自实现GetProcAddress 896
第二篇：PE文件结构操控技术 905
2.1 PE结构映射进内存 906
2.2 DOS文件头详细解析 910
2.3 PE文件头详细解析 914
2.3.1 IMAGE_FILE_HEADER 2.3.1
2.3.2 IMAGE_OPTINAL_HEADER 2.3.2
2.4 节表详细解析 921
2.5 导入表详细解析 924
2.5.1 导入表原理分析 2.5.1
2.5.2 IMAGE_IMPORT_DESCRIPTOR 2.5.2
2.5.3 枚举导入表流程 2.5.3
2.6 导出表详细解析 931
2.7 重定位表详细解析 934
2.8 资源表详细解析 939
2.9 重建导入表 942
2.10 重建重定位表 950
2.11 添加新的节区 955
2.12 实现字节注入 959
2.13 实现代码段加密 966
2.14 地址之间的转换 969
第三篇：动态链接库注入技术 977
3.1 常规远程线程注入 977
3.2 远程APC异步注入 980
3.3 突破会话0强力注入 983
3.4 全局消息钩子注入 988
第四篇：应用层Hook挂钩技术 991
4.1 钩子技术原理 992
4.2 x32 Inline Hook 995
4.3 x64 Inline Hook 999
4.4 IAT Hook 1005
4.5 EAT Hook 1015
4.6 MinHook 1018
第五篇：内存与磁盘CRC校验技术 1023
5.1 内存CRC完整性检测 1026
5.2 磁盘CRC完整性检测 1029
第六篇：内存特征定位与补丁技术 1033
6.1 KMP算法搜索机器码 1033
6.1.1 遍历输出进程内存 6.1.1
6.1.2 使用KMP搜索特征码 6.1.2
6.2 Sunday搜索内存特征 1036
6.2.1 字符串与特征码转换 6.2.1
6.2.2 搜索内存区域特征 6.2.2
6.2.3 搜索整块内存区域 6.2.3
6.2.4 应用动态内存补丁 6.2.4
第七篇：应用进程线程操控技术 1051
7.1 内存块枚举 1051
7.2 创建新进程 1061
7.3 枚举进程相关 1065
7.4 枚举进程权限 1067
7.5 判断进程状态 1070
7.6 挂起/恢复进程 1073
7.7 进程内存读写 1084
第八篇：进程反调试应用技术 1098
8.1 TEB/PEB 1098
8.2 BeingDebugged 1102
8.3 NtGlobalFlag 1106
8.4 ProcessHeap 1108
8.5 DebuggerPresent 1111
8.6 STARTUPINFO 1112
8.7 父进程检测反调试 1113
8.8 异常处理机制反调试 1114
8.9 RDTSC时钟检测反调试 1115
8.10 TLS线程局部存储反调试 1116
第九篇：多线程与线程同步技术 1118
9.1 运用API创建多线程 1118
9.1.1 CreateThread 9.1.1
9.1.2 BeginThreadex 9.1.2
9.2 运用API实现线程同步 1123
9.2.1 CreateEvent 9.2.1
9.2.2 CreateSemaphore 9.2.2
9.2.3 CreateMutex 9.2.3
9.2.4 ThreadParameters 9.2.4
9.2.5 ThreadPool 9.2.5
第十篇：调试事件与反汇编技术 1145
10.1 调试事件获取寄存器 1147
10.2 调试事件获取DLL装载 1150
10.3 调试事件转存进程内存 1152
10.4 认识Capstone反汇编引擎 1156
10.5 认识XEDParse汇编引擎 1163
10.6 开发反汇编调试器 1165
10.6.1 寄存器系列函数 10.6.1
10.6.2 软件断点函数 10.6.2
10.6.3 内存断点函数 10.6.3
10.6.4 硬件断点函数 10.6.4
10.6.5 反汇编功能函数 10.6.5
10.6.6 单步步过/步进函数 10.6.6
第十一篇：文件与磁盘操作技术 1117
11.1 DelteFile 1117
11.2 CopyFile 1178
11.3 MoveFile 1179
11.4 ReadFile 1181
11.5 FindNextFile 1184
11.6 切割文件名与路径 1185
11.7 遍历目录下文件 1187
11.8 重置文件时间戳 1189
11.9 遍历磁盘容量 1190
11.10 遍历盘符并存储 1194
11.11 实现磁盘格式化 1195
11.12 移除指定磁盘 1195
11.13 输出磁盘分区表 1198
11.14 遍历文件特定路径 1201
11.15 监控目录文件变化 1204
第十二篇：键盘鼠标模拟技术 1204
12.1 键盘鼠标监控钩子 1204
12.2 实现键盘鼠标模拟 1211
第十三篇：应用DirectX窗体绘制技术 1227
13.1引用DirectX9引擎 1227
13.1.1 初始化变量 13.1.1
13.1.2 LPDIRECT3D9 13.1.2
13.1.3 LPDIRECT3DDEVICE9 13.1.3
13.1.4 LPDIRECT3DVERTEXBUFFER9 13.1.4
13.1.5初始化绘图引擎 13.1.5
13.2外部DirectX绘制实现 1236
13.2.1 必要参数定义 13.2.1
13.2.2 初始化绘图引擎 13.2.2
13.2.3 初始化并创建消息循环 13.2.3
13.2.4 封装实现绘图函数 13.2.4
13.2.5 实现屏幕绘制功能 13.2.5
13.3运用LyDrawLib库绘制 1243
13.3.1 绘制实心矩形 13.3.1
13.3.2 绘制空心矩形 13.3.2
13.3.3 绘制进度条 13.3.3
13.3.4 绘制圆形及准星 13.3.4
13.3.5 绘制文本字符串 13.3.5
13.3.6 绘制功能菜单 13.3.6
13.4 DirectX内部劫持绘制 1253
13.4.1 封装Hook劫持功能 13.4.1
13.4.2 自定义MyEndScene函数 13.4.2
13.4.3 初始化与绘制图形 13.4.3
第十四篇：网络套接字编程入门 1260
14.1 Socket 简单通信流程 1260
14.2 Socket 反向远程命令行 1265
14.3 Socket 字符串分块传输 1268
14.4 Socket 双向数据通信 1272
14.5 Socket 应用组播通信 1276
14.6 Socket 应用结构体传输 1279
14.7 Socket 循环结构体传输 1283
14.8 Socket 一收一发通信 1287
14.9 Socket 高效文件传输 1292
14.10 Socket 选择套接字通信 1298
14.11 Socket 基于时间加密通信 1304
第十五篇：主机路由追踪技术 1311
15.1 通过域名取IP地址 1312
15.2 主机探测与路由追踪 1313
第十六篇：端口探测扫描技术 1321
16.1 实现Socket端口探测 1322
16.2 实现ARP主机探测 1328
第十七篇：重叠后门反弹技术 1332
17.1 隐藏执行CMD 1333
17.2 无管道正向CMD 1336
17.3 无管道反向CMD 1338
第十八篇：操控网络数据包技术 1340
18.1 原生套接字抓包 1340
18.2 使用NPCAP抓包 1351
18.3 构建实现ARP欺骗 1372
第十九篇：基于ASIO网络编程技术 1380
19.1 同步TCP通信 1381
19.2 同步UDP通信 1384
19.3 同步多线程通信 1386
19.4 同步远程命令执行 1388
19.5 同步传输结构体 1390
19.6 同步Base64文本传输 1392
19.7 同步传输序列化数据 1395
19.8 同步异或加密传输 1398
19.9 同步实现字典传输 1401
19.10 同步实现文件传输 1403
19.11 同步获取远程目录 1409
19.12 同步获取远程进程 1413
19.13 同步发送TCP流数据 1416
第二十篇：OpenSSL加密传输技术 1420
20.1 字符BASE64压缩算法 1421
20.2 非对称RSA加解密算法 1423
20.3 对称AES加解密算法 1430
20.4 套接字AES加密传输 1433
20.5 套接字RSA加密传输 1437
20.6 套接字分发RSA公钥 1448
20.7 套接字SSL加密传输 1456
20.8 套接字SSL传输文件 1463
第二十一篇：Python安全编程技术 1469
21.1 使用PEfile分析PE文件 1470
21.1.1 打开并加载PE文件 21.1.1
21.1.2 解析PE头部数据 21.1.2
21.1.3 解析节表数据 21.1.3
21.1.4 节区RVA与FOA互转 21.1.4
21.1.5 解析数据为Hex格式 21.1.5
21.1.6 解析数据目录表 21.1.6
21.1.7 解析导入导出表 21.1.7
21.2 使用Scapy实现端口探测 1480
21.2.1 端口扫描基础 21.2.1
21.2.2 ICMP构建与发送 21.2.2
21.2.3 TCP全连接扫描 21.2.3
21.2.4 SYN半开放扫描 21.2.4
21.2.5 UDP无状态扫描 21.2.5
21.3 使用DPKT分析数据包 1492
21.3.1 抓取PCAP数据包 21.3.1
21.3.2 使用Google地图定位 21.3.2
21.4 使用Scapy实现网络攻击 1501
21.4.1 SynFlood攻击 21.4.1
21.4.2 SockStress攻击 21.4.2
21.4.3 DNS查询攻击 21.4.3
21.4.4 ARP中间人攻击 21.4.4
21.5 使用HTTP解析库 1514
21.5.1 Request 21.5.1
21.5.2 BeautifulSoup 21.5.2
21.5.3 Selenium 21.5.3
21.6 运用CRC32校验技术 1535
21.6.1 使用CRC校验技术 21.6.1
21.6.2 使用CRC图片去重 21.6.2
21.7 网络编程中的应用 1544
21.7.1 实现网站服务器 21.7.1
21.7.2 实现端口流量转发 21.7.2
21.7.3 实现Web指纹识别 21.7.3
第三部分：软件安全卷
第一篇：熟悉x64dbg调试器 1552
1.1 如何启动调试器 1553
1.2 熟悉x64dbg窗口 1554
1.3 熟悉x64dbg断点 1559
1.4 熟悉x64dbg代码跟踪 1562
1.5 为x64dbg编写插件 1563
第二篇：熟悉CheatEngine修改器 1570
2.1 精确数值扫描 1573
2.2 未知数值扫描 1576
2.3 浮点数扫描 1579
2.4 代码替换功能 1580
2.5 寻找数值指针 1584
2.6 代码注入功能 1589
2.7 多级指针查找 1594
2.8 寻找共享代码 1601
第三篇：熟悉IDAPro静态反汇编器 1605
3.1 IDA编写IDC脚本 1608
3.2 IDC中常用函数 1618
第四篇：探索LyScript漏洞挖掘插件 1623
4.1 如何使用插件 1625
4.1.1读取或设置寄存器参数 4.1.1
4.1.2使用调试控制系列函数 4.1.2
4.1.3使用断点设置系列函数 4.1.3
4.1.4使用堆栈系列函数 4.1.4
4.1.5使用反汇编系列函数 4.1.5
4.1.6使用内存读写系列函数 4.1.6
4.2 针对PE文件的扫描 1633
4.2.1获取PE结构内存节表 4.2.1
4.2.2计算节表内存Hash散列值 4.2.2
4.2.3验证PE启用的保护模式 4.2.3
4.2.4 PE结构的FOA/VA/RAV转换 4.2.4
4.2.5PE结构检索SafeSEH内存地址 4.2.5
4.3 搜索内存可利用指令 1644
4.3.1搜索可利用汇编指令集 4.3.1
4.3.2搜索可利用机器码 4.3.2
4.4 绕过反调试保护机制 1647
4.5 探索钩子劫持技术 1650
4.5.1探索反汇编写出函数原理 4.5.1
4.5.2实现Hook改写MsgBox弹窗 4.5.2
4.6 内存扫描与查壳实现 1657
4.7 应用层的钩子扫描 1661
4.8 学会扫描应用堆栈 1666
4.9 内存处理与差异对比 1670
4.9.1实现ShellCode的灵活注入 4.9.1
4.9.2内存区域交换与对比 4.9.2
4.9.3内存与磁盘机器码对比 4.9.3
4.10 反汇编功能的封装 1676
4.10.1搜索内存机器码特征 4.10.1
4.10.2搜索内存反汇编特征 4.10.2
4.10.3获取上下一条汇编指令 4.10.3
第五篇：远程栈溢出分析与利用 1683
5.1 缓冲区溢出与攻防博弈 1683
5.1.1 GS堆栈缓冲区溢出检测保护 5.1.1
5.1.2 SafeSEH安全结构化异常处理保护 5.1.2
5.1.3 SEHOP堆栈SEH覆盖保护 5.1.3
5.1.4 ASLR地址布局随机化保护 5.1.4
5.1.5 DEP堆栈数据执行保护 5.1.5
5.2 基于ROP漏洞挖掘与利用 1687
5.2.1溢出是如何产生的 5.2.1
5.2.2漏洞分析与挖掘 5.2.2
5.2.3寻找JMP跳板指令 5.2.3
5.2.4组合脚本并攻击 5.2.4
5.2.5 ROP绕过DEP保护 5.2.5
第六篇：逆向分析植物大战僵尸 1710
6.1 增加自己的阳光 1710
6.2 实现自动收集阳光 1716
6.3 寻找葵花生产速度 1721
6.4 寻找阳光掉落CALL 1731
6.5 寻找任意种植CALL 1740
6.6 寻找全屏攻击CALL 1748
6.7 寻找召唤僵尸CALL 1754
6.8 分析植物无冷却 1761
6.9 分析植物攻击速度 1771
第七篇：逆向分析反恐精英起源 1776
7.1 运用Hook实现上色透视 1776
7.1.1寻找DrawIndexedPrimitive基址 7.1.1
7.1.2劫持DrawIndexedPrimitive函数 7.1.2
7.1.3寻找模型ID与透视 7.1.3
7.2 寻找游戏基址数据 1799
7.2.1 寻找无限金币基址 7.2.1
7.2.2 寻找FOV视场角基址 7.2.2
7.2.3 寻找本人鼠标角度基址 7.2.3
7.2.4 寻找本人坐标数据基址 7.2.4
7.2.5 寻找敌人坐标数据基址 7.2.5
7.2.6 寻找敌人血量基址 7.2.6
7.2.7 寻找玩家数量基址 7.2.7
7.2.8 寻找当前阵营基址 7.2.8
7.3 三角函数算法透视 1827
7.3.1 第一象限求角 7.3.1
7.3.2 第二象限求角 7.3.2
7.3.3 第三四象限求角 7.3.3
7.3.4 分析FOV视场角度 7.3.4
7.3.5 三维横坐标转屏幕X坐标 7.3.5
7.3.6 三维纵坐标转屏幕Y坐标 7.3.6
7.4 矩阵透视算法分析 1835
7.4.1 寻找世界矩阵 7.4.1
7.4.2 实现矩阵透视 7.4.2
第四部分：内核安全卷
第一篇：驱动开发环境配置 1844
1.1 配置驱动开发环境 1844
1.2 配置驱动开发模板 1849
1.3 配置驱动双机调试 1855
1.4 测试模式过DSE签名 1862
第二篇：驱动开发基础知识 1864
2.1 内核链表与结构体 1864
2.2 内核自旋锁结构 1868
2.3 内核字符串转换方法 1874
2.3.1 初始化字符串 2.3.1
2.3.2 字符串与整数转换 2.3.2
2.3.3 字符串ANSI与UNICODE 2.3.3
2.3.4 字符串连接操作 2.3.4
2.4 内核字符串拷贝与比较 1886
2.4.1 内核中的空间分配 2.4.1
2.4.2 内核中的字符串拷贝 2.4.2
2.4.3 内核中的字符串比较 2.4.3
2.5 探索DRIVER_OBJECT结构 1893
2.6 内核使用IO/DPC定时器 1899
第三篇：内核驱动读写技术 1906
3.1 内核远程堆分配与销毁 1906
3.2 内核CR3切换读写内存 1912
3.3 内核MDL读写进程内存 1919
3.3.1 MDL读取内存步骤 3.3.1
3.3.2 MDL写入内存步骤 3.3.2
3.4 通过内存拷贝读写内存 1926
3.5 内核R3与R0内存映射 1930
3.5.1应用层映射到内核层 3.5.1
3.5.2内核层映射到应用层 3.5.2
3.6 内核进程汇编与反汇编 1940
3.6.1内存反汇编的应用 3.6.1
3.6.2内存汇编的应用 3.6.2
3.7 内核解析内存四级页表 1953
3.8 内核读写内存浮点数 1958
3.9 内核读写内存多级偏移 1965
3.10 内核物理内存寻址读写 1973
3.10.1物理页转换算法分析 3.10.1
3.10.2.实现物理页读内存 3.10.2
3.10.3实现物理页写内存 3.10.3
第四篇：内核进程线程操作 1982
4.1 内核中进程与句柄互转 1983
4.1.1进程PID与进程HANDLE转换 4.1.1
4.1.2进程PID转换为EProcess结构 4.1.2
4.1.3进程HANDLE与EPROCESS转换 4.1.3
4.2 内核中枚举进线程与模块 1990
4.2.1内核中实现枚举进程 4.2.1
4.2.2内核中实现枚举线程 4.2.2
4.2.3内核中实现枚举进程模块 4.2.3
4.2.4内核中实现枚举加载的驱动 4.2.4
4.2.5内核中实现获取特定进程PID 4.2.5
4.2.6内核中实现判断进程状态 4.2.6
4.3 监控进程与线程对象操作 2010
4.3.1实现监控进程打开与关闭 4.3.1
4.3.2实现监控进程中的模块加载 4.3.2
4.4 内核监控进程与线程创建 2023
4.5 内核中实现进程数据转储 2029
4.6 内核遍历进程VAD结构体 2036
4.7 运用VAD隐藏R3内存思路 2052
4.8 内核摘链DKOM进程隐藏 2055
4.9 内核无痕隐藏自身分析 2059
4.10 内核强制结束进程运行 2068
第五篇：内核模块与钩子技术 2074
5.1 内核判断驱动加载状态 2075
5.2 内核取KERNEL模块基址 2082
5.3 内核取应用层模块基址 2086
5.4 内核通过PEB取进程参数 2089
5.5 内核断链隐藏驱动程序 2096
5.6 内核特征码定位搜索 2098
5.7 取进程模块函数地址 2102
5.7.1取进程中模块基址 5.7.1
5.7.2取模块内函数基址 5.7.2
5.8 内核LDE引擎取汇编长度 2105
5.9 内核InlineHook挂钩技术 2108
5.10 摘除InlineHook内核钩子 2111
第六篇：内核枚举技术 2133
6.1 内核枚举SSDT表基址 2133
6.2 内核枚举SSSDT表基址 2141
6.3 内核枚举IoTimer定时器 2148
6.4 内核枚举DpcTimer定时器 2157
6.5 内核枚举PspCidTable句柄表 2178
6.6 内核枚举Minifilter微过滤驱动 2190
6.7 内核枚举LoadImage映像回调 2194
6.8 内核枚举Registry注册表回调 2202
6.9 内核枚举进线程ObCall回调 2210
第七篇：内核监控技术 2216
7.1 内核监控进程与线程回调 2217
7.2 内核注册并监控对象回调 2224
7.3 内核监视LoadImage映像回调 2234
7.4 内核运用LoadImage屏蔽驱动 2236
7.5 内核监控Register注册表回调 2243
7.6 内核监控FileObject文件回调 2253
第八篇：内核文件与注册表 2261
8.1 内核文件读写系列函数 2261
8.1.1创建文件或目录 8.1.1
8.1.2重命名文件或目录 8.1.2
8.1.3读取文件大小 8.1.3
8.1.4内核文件读写 8.1.4
8.1.5实现文件读写传递 8.1.5
8.2 内核解锁与强删文件 2283
8.3 内核遍历文件或目录 2297
8.4 文件微过滤驱动入门 2302
8.5 内核注册表增删改查 2316
8.5.1 ZwCreateKey 8.5.1
8.5.2 ZwRenameKey 8.5.2
8.5.3 ZwSetValueKey 8.5.3
8.5.4 ZwQueryValueKey 8.5.4
8.5.5 ZwEnumerateKey 8.5.5
8.5.6 ZwEnumerateValueKey 8.5.6
8.5.7 ZwDeleteValueKey 8.5.7
第九篇：内核PE结构与注入 2342
9.1 内核特征扫描PE代码段 2343
9.2 内核解析PE结构导出表 2358
9.3 内核解析PE结构节表 2367
9.3.1 DOS头结构解析 9.3.1
9.3.2 PE头结构解析 9.3.2
9.4 内核PE结构VA与FOA转换 2374
9.4.1 FOA偏移转换为VA偏移 9.4.1
9.4.2 VA偏移转换为FOA偏移 9.4.2
9.4.3 RVA偏移转换为FOA偏移 9.4.3
9.5 内核实现SSDT挂钩与摘钩 2382
9.6 内核扫描SSDT挂钩状态 2399
9.7 PE导出函数与RVA转换 2407
9.8 内核RIP劫持实现DLL注入 2440
9.9 内核远程线程实现DLL注入 2475
9.10 内核LoadLibrary实现DLL注入 2485
9.11 内核ShellCode实现线程注入 2492
